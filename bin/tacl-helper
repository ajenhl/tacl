#!/usr/bin/env python3

import argparse
import logging
import os

import tacl


def main ():
    parser = generate_parser()
    args = parser.parse_args()
    configure_logging(args.verbose)
    args.func(args)

def add_common_arguments (parser):
    """Adds common arguments for all parsers."""
    help = 'display debug information; multiple -v options increase the verbosity'
    parser.add_argument('-v', '--verbose', action='count', help=help)

def add_db_arguments (parser):
    """Adds common arguments for the database subcommands to `parser`."""
    parser.add_argument('-m', '--memory', action='store_true',
                        help='use RAM for temporary database storage')
    parser.add_argument('-r', '--ram', default=3, type=int,
                        help='number of gigabytes of RAM to use')
    parser.add_argument('db', metavar='DATABASE', help='path to database file')
    parser.add_argument('corpus', help='path to corpus', metavar='CORPUS')

def configure_logging (verbose):
    logger = logging.getLogger('tacl-helper')
    if not verbose:
        log_level = logging.WARNING
    elif verbose == 1:
        log_level = logging.INFO
    else:
        log_level = logging.DEBUG
    logging.basicConfig(format='%(asctime)s %(levelname)s: %(message)s',
                        level=log_level)

def _copy_options (args):
    """Returns a string form of the options in `args`."""
    options = []
    if args.memory:
        options.append('--memory')
    if args.ram:
        options.append('--ram {}'.format(args.ram))
    if args.verbose:
        options.append('-{}'.format('v' * args.verbose))
    return ' ' + ' '.join(options)

def generate_parser ():
    parser = argparse.ArgumentParser(
        description='Perform helpful but non-essential tacl-related functions')
    subparsers = parser.add_subparsers(title='subcommands')
    generate_text_against_corpus_subparser(subparsers)
    generate_text_in_corpus_subparser(subparsers)
    return parser

def generate_text_against_corpus_subparser (subparsers):
    description='Generate a script to compare each text of a corpus against all the texts in another corpus'
    help='generate a script to compare each text of a corpus against all the texts in another corpus'
    parser = subparsers.add_parser('text-against-corpus',
                                   description=description, help=help)
    parser.set_defaults(func=text_against_corpus)
    add_common_arguments(parser)
    add_db_arguments(parser)
    a_texts_help = 'file containing text names to compare (one per line)'
    b_texts_help = 'file containing corpus text names to be compared against (one per line)'
    parser.add_argument('a_texts', help=a_texts_help, metavar='FILES_LIST',
                        type=argparse.FileType('r'))
    parser.add_argument(
        'b_texts', help=b_texts_help, metavar='CORPUS_FILES_LIST',
        type=argparse.FileType('r'))
    parser.add_argument('output_dir',
                        help='output directory for script and catalogue files')

def generate_text_in_corpus_subparser (subparsers):
    description='Generate a script to compare each text of a corpus with all the other texts of that corpus'
    help='generate a script to compare each text of a corpus with all the other texts of that corpus'
    parser = subparsers.add_parser('text-in-corpus', description=description,
                                   help=help)
    parser.set_defaults(func=text_in_corpus)
    add_common_arguments(parser)
    add_db_arguments(parser)
    texts_help = 'file containing text names to examine (one per line)'
    parser.add_argument('texts', help=texts_help, type=argparse.FileType('r'))
    parser.add_argument('output_dir',
                        help='output directory for script and catalogue files')

def text_against_corpus (args):
    a_texts = args.a_texts.read().strip().split()
    b_texts = args.b_texts.read().strip().split()
    output_dir = os.path.abspath(args.output_dir)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    catalogue = tacl.Catalogue({text : 'REST' for text in b_texts})
    commands = []
    options = _copy_options(args)
    for text in a_texts:
        text_name = os.path.splitext(text)[0]
        catalogue_path = os.path.join(
            output_dir, '{}-catalogue.txt'.format(text_name))
        results_path = os.path.join(
            output_dir, '{}-results.csv'.format(text_name))
        reduced_path = os.path.join(
            output_dir, '{}-reduced.csv'.format(text_name))
        catalogue[text] = 'A'
        catalogue.save(catalogue_path)
        query_command = 'tacl intersect{} {} {} {} > {}\n'.format(
            options, args.db, args.corpus, catalogue_path, results_path)
        report_command = 'tacl report --reduce --remove REST {} > {}\n'.format(
            results_path, reduced_path)
        commands.extend((query_command, report_command))
        del catalogue[text]
    commands_path = os.path.join(output_dir, 'commands')
    with open(commands_path, 'w') as fh:
        fh.writelines(commands)

def text_in_corpus (args):
    texts = args.texts.read().strip().split()
    output_dir = os.path.abspath(args.output_dir)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    catalogue = tacl.Catalogue({text : 'REST' for text in texts})
    commands = []
    options = _copy_options(args)
    for text in texts:
        text_name = os.path.splitext(text)[0]
        catalogue_path = os.path.join(output_dir,
                                      '{}-catalogue.txt'.format(text_name))
        results_path = os.path.join(output_dir,
                                    '{}-results.csv'.format(text_name))
        reduced_path = os.path.join(output_dir,
                                    '{}-reduced.csv'.format(text_name))
        catalogue[text] = 'A'
        catalogue.save(catalogue_path)
        query_command = 'tacl intersect{} {} {} {} > {}\n'.format(
            options, args.db, args.corpus, catalogue_path, results_path)
        report_command = 'tacl report --reduce --remove REST {} > {}\n'.format(
            results_path, reduced_path)
        commands.extend((query_command, report_command))
        catalogue[text] = 'REST'
    commands_path = os.path.join(output_dir, 'commands')
    with open(commands_path, 'w') as fh:
        fh.writelines(commands)



if __name__ == '__main__':
    main()
