#!/usr/bin/env python3

import argparse
import io
import logging
import re
import sys
import textwrap

import tacl
from tacl import constants


def main ():
    parser = generate_parser()
    args = parser.parse_args()
    configure_logging(args.verbose)
    try:
        args.func(args)
    except Exception as err:
        print('Error: {0}'.format(err))
        sys.exit(1)

def add_common_arguments (parser):
    """Adds common arguments for all parsers."""
    parser.add_argument('-v', '--verbose', action='count',
                        help=constants.VERBOSE_HELP)

def add_db_arguments (parser):
    """Adds common arguments for the database subcommands to `parser`."""
    parser.add_argument('-m', '--memory', action='store_true',
                        help=constants.DB_MEMORY_HELP)
    parser.add_argument('-r', '--ram', default=3, help=constants.DB_RAM_HELP,
                        type=int)
    parser.add_argument('db', help=constants.DB_DATABASE_HELP,
                        metavar='DATABASE')
    parser.add_argument('corpus', help=constants.DB_CORPUS_HELP,
                        metavar='CORPUS')

def add_input_arguments (parser):
    parser.add_argument('-i', '--input', help=constants.INPUT_RESULTS_HELP,
                        metavar='INPUT_RESULTS')

def add_query_arguments (parser):
    parser.add_argument('catalogue', help=constants.CATALOGUE_CATALOGUE_HELP,
                        metavar='CATALOGUE')

def configure_logging (verbose):
    logger = logging.getLogger('tacl')
    if not verbose:
        log_level = logging.WARNING
    elif verbose == 1:
        log_level = logging.INFO
    else:
        log_level = logging.DEBUG
    logging.basicConfig(format='%(asctime)s %(levelname)s: %(message)s',
                        level=log_level)

def generate_parser ():
    parser = argparse.ArgumentParser(
        description=constants.TACL_DESCRIPTION,
        formatter_class=ParagraphFormatter)
    subparsers = parser.add_subparsers(title='subcommands')
    generate_catalogue_subparser(subparsers)
    generate_counts_subparser(subparsers)
    generate_diff_subparser(subparsers)
    generate_intersect_subparser(subparsers)
    generate_ngrams_subparser(subparsers)
    generate_report_subparser(subparsers)
    generate_strip_subparser(subparsers)
    return parser

def generate_catalogue (args):
    catalogue = tacl.Catalogue()
    catalogue.generate(args.corpus, args.label)
    catalogue.save(args.catalogue)

def generate_catalogue_subparser (subparsers):
    parser = subparsers.add_parser(
        'catalogue', description=constants.CATALOGUE_DESCRIPTION,
        epilog=constants.CATALOGUE_EPILOG,
        formatter_class=ParagraphFormatter, help=constants.CATALOGUE_HELP)
    add_common_arguments(parser)
    parser.set_defaults(func=generate_catalogue)
    parser.add_argument('corpus', help=constants.DB_CORPUS_HELP,
                        metavar='CORPUS')
    add_query_arguments(parser)
    parser.add_argument('-l', '--label', default='',
                        help=constants.CATALOGUE_LABEL_HELP)

def generate_counts_subparser (subparsers):
    parser = subparsers.add_parser(
        'counts', description=constants.COUNTS_DESCRIPTION,
        epilog=constants.COUNTS_EPILOG, formatter_class=ParagraphFormatter,
        help=constants.COUNTS_HELP)
    parser.set_defaults(func=ngram_counts)
    add_common_arguments(parser)
    add_db_arguments(parser)
    add_query_arguments(parser)

def generate_diff_subparser (subparsers):
    parser = subparsers.add_parser(
        'diff', description=constants.DIFF_DESCRIPTION,
        epilog=constants.DIFF_EPILOG, formatter_class=ParagraphFormatter,
        help=constants.DIFF_HELP)
    parser.set_defaults(func=ngram_diff)
    group = parser.add_mutually_exclusive_group()
    add_input_arguments(group)
    group.add_argument('-a', '--asymmetric', help=constants.ASYMMETRIC_HELP,
                       metavar='LABEL')
    add_common_arguments(parser)
    add_db_arguments(parser)
    add_query_arguments(parser)

def generate_intersect_subparser (subparsers):
    parser = subparsers.add_parser(
        'intersect', description=constants.INTERSECT_DESCRIPTION,
        epilog=constants.INTERSECT_EPILOG, formatter_class=ParagraphFormatter,
        help=constants.INTERSECT_HELP)
    parser.set_defaults(func=ngram_intersection)
    add_input_arguments(parser)
    add_common_arguments(parser)
    add_db_arguments(parser)
    add_query_arguments(parser)

def generate_ngrams (args):
    store = get_data_store(args)
    corpus = get_corpus(args)
    store.add_ngrams(corpus, args.min_size, args.max_size)

def generate_ngrams_subparser (subparsers):
    parser = subparsers.add_parser(
        'ngrams', description=constants.NGRAMS_DESCRIPTION,
        formatter_class=ParagraphFormatter, help=constants.NGRAMS_HELP)
    parser.set_defaults(func=generate_ngrams)
    add_common_arguments(parser)
    add_db_arguments(parser)
    parser.add_argument('min_size', help=constants.NGRAMS_MINIMUM_HELP,
                        metavar='MINIMUM', type=int)
    parser.add_argument('max_size', help=constants.NGRAMS_MAXIMUM_HELP,
                        metavar='MAXIMUM', type=int)

def generate_report (args):
    if args.results == '-':
        results = io.TextIOWrapper(sys.stdin.buffer, encoding='utf-8',
                                   newline='')
    else:
        results = open(args.results, 'r', encoding='utf-8', newline='')
    report = tacl.Report(results)
    if args.reduce:
        report.reduce()
    if args.reciprocal:
        report.reciprocal_remove()
    if args.min_texts or args.max_texts:
        report.prune_by_text_count(args.min_texts, args.max_texts)
    if args.min_size or args.max_size:
        report.prune_by_ngram_size(args.min_size, args.max_size)
    if args.min_count or args.max_count:
        report.prune_by_ngram_count(args.min_count, args.max_count)
    if args.remove:
        report.remove_label(args.remove)
    report.csv(sys.stdout)

def generate_report_subparser (subparsers):
    parser = subparsers.add_parser(
        'report', description=constants.REPORT_DESCRIPTION,
        epilog=constants.REPORT_EPILOG, formatter_class=ParagraphFormatter,
        help=constants.REPORT_HELP)
    add_common_arguments(parser)
    parser.set_defaults(func=generate_report)
    parser.add_argument('--min-count', dest='min_count',
                        help=constants.REPORT_MINIMUM_COUNT_HELP,
                        metavar='COUNT', type=int)
    parser.add_argument('--max-count', dest='max_count',
                        help=constants.REPORT_MAXIMUM_COUNT_HELP,
                        metavar='COUNT', type=int)
    parser.add_argument('--min-size', dest='min_size',
                        help=constants.REPORT_MINIMUM_SIZE_HELP, metavar='SIZE',
                        type=int)
    parser.add_argument('--max-size', dest='max_size',
                        help=constants.REPORT_MAXIMUM_SIZE_HELP, metavar='SIZE',
                        type=int)
    parser.add_argument('--min-texts', dest='min_texts',
                        help=constants.REPORT_MINIMUM_TEXT_HELP,
                        metavar='COUNT', type=int)
    parser.add_argument('--max-texts', dest='max_texts',
                        help=constants.REPORT_MAXIMUM_TEXT_HELP,
                        metavar='COUNT', type=int)
    parser.add_argument('--reciprocal', action='store_true',
                        help=constants.REPORT_RECIPROCAL_HELP)
    parser.add_argument('--reduce', action='store_true',
                        help=constants.REPORT_REDUCE_HELP)
    parser.add_argument('--remove', help=constants.REPORT_REMOVE_HELP,
                        metavar='LABEL', type=str)
    parser.add_argument('results', help=constants.REPORT_RESULTS_HELP,
                        metavar='RESULTS')

def generate_strip_subparser (subparsers):
    parser = subparsers.add_parser(
        'strip', description=constants.STRIP_DESCRIPTION,
        epilog=constants.STRIP_EPILOG, help=constants.STRIP_HELP)
    parser.set_defaults(func=strip_texts)
    add_common_arguments(parser)
    parser.add_argument('input', help=constants.STRIP_INPUT_HELP,
                        metavar='INPUT')
    parser.add_argument('output', help=constants.STRIP_OUTPUT_HELP,
                        metavar='OUTPUT')

def get_corpus (args):
    return tacl.Corpus(args.corpus)

def get_catalogue (args):
    catalogue = tacl.Catalogue()
    catalogue.load(args.catalogue)
    return catalogue

def get_input_fh (args):
    input_fh = None
    if args.input:
        input_fh = open(args.input, 'r', newline='')
    return input_fh

def get_data_store (args):
    return tacl.DataStore(args.db, args.memory, args.ram)

def ngram_counts (args):
    store = get_data_store(args)
    corpus = get_corpus(args)
    catalogue = get_catalogue(args)
    store.validate(corpus, catalogue)
    store.counts(catalogue, sys.stdout)

def ngram_diff (args):
    store = get_data_store(args)
    corpus = get_corpus(args)
    catalogue = get_catalogue(args)
    input_fh = get_input_fh(args)
    store.validate(corpus, catalogue)
    if input_fh:
        store.diff_supplied(catalogue, input_fh, sys.stdout)
    elif args.asymmetric:
        store.diff_asymmetric(catalogue, args.asymmetric, sys.stdout)
    else:
        store.diff(catalogue, sys.stdout)

def ngram_intersection (args):
    store = get_data_store(args)
    corpus = get_corpus(args)
    catalogue = get_catalogue(args)
    input_fh = get_input_fh(args)
    store.validate(corpus, catalogue)
    if input_fh:
        store.intersection_supplied(catalogue, input_fh, sys.stdout)
    else:
        store.intersection(catalogue, sys.stdout)

def strip_texts (args):
    stripper = tacl.Stripper(args.input, args.output)
    stripper.strip_files()


class ParagraphFormatter (argparse.HelpFormatter):

    """argparse formatter to maintain paragraph breaks in text, while
    wrapping those blocks.

    Code minimally adapted from the patch at
    http://bugs.python.org/file28091, authored by rurpy2.

    """

    def _split_lines (self, text, width):
        return self._para_reformat(text, width, multiline=True)

    def _fill_text (self, text, width, indent):
        lines = self._para_reformat(text, width, indent, True)
        return '\n'.join(lines)

    def _para_reformat (self, text, width, indent='', multiline=False):
        new_lines = list()
        main_indent = len(re.match(r'( *)',text).group(1))

        def blocker (text):
            """On each call yields 2-tuple consisting of a boolean and
            the next block of text from 'text'.  A block is either a
            single line, or a group of contiguous lines.  The former
            is returned when not in multiline mode, the text in the
            line was indented beyond the indentation of the first
            line, or it was a blank line (the latter two jointly
            referred to as "no-wrap" lines).  A block of concatenated
            text lines up to the next no-wrap line is returned when
            in multiline mode.  The boolean value indicates whether
            text wrapping should be done on the returned text."""
            block = list()
            for line in text.splitlines():
                line_indent = len(re.match(r'( *)',line).group(1))
                isindented = line_indent - main_indent > 0
                isblank = re.match(r'\s*$', line)
                if isblank or isindented:
                    # A no-wrap line.
                    if block:
                        # Yield previously accumulated block of text
                        # if any, for wrapping.
                        yield True, ''.join(block)
                        block = list()
                    # And now yield our no-wrap line.
                    yield False, line
                else:
                    # We have a regular text line.
                    if multiline:
                        # In multiline mode accumulate it.
                        block.append(line)
                    else:
                        # Not in multiline mode, yield it for
                        # wrapping.
                        yield True, line
            if block:
                # Yield any text block left over.
                yield (True, ''.join(block))

        for wrap, line in blocker(text):
            if wrap:
                # We have either a single line or a group of
                # concatented lines.  Either way, we treat them as a
                # block of text and wrap them (after reducing multiple
                # whitespace to just single space characters).
                line = self._whitespace_matcher.sub(' ', line).strip()
                # Textwrap will do all the hard work for us.
                new_lines.extend(textwrap.wrap(text=line, width=width,
                                               initial_indent=indent,
                                               subsequent_indent=indent))
            else:
                # The line was a no-wrap one so leave the formatting
                # alone.
                new_lines.append(line[main_indent:])
        return new_lines


if __name__ == '__main__':
    main()
